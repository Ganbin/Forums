// validation rule for a category : must have a titlemodel.Category.events.validate = function() {	if(this.title == '' || this.title == null ){		return {error : 10, errorMessage:'Must have a title'};	}};model.Category.events.save = function() {	if(this.title == '' || this.title == null ){		return { error: 10, errorMessage:'Must have a title' };	}};// Restricting query for the category dataclass// This query return only the data accessible to the current usermodel.Category.events.restrict = function() {		var namespace = require('namespace'); // require the namespace module		var returnCol = ds.Category.createEntityCollection(); // create an empty entityCollection	var curSess = currentSession(); // get the currentSession and assign it to the curSess variable		// Declaration of all my variable	var allPublicAccesses;	var allUserAccesses;	var promoteToken;	var accessIDArray = [];	var categoryResult;			if(curSess.belongsTo('Administrateur')){ // if the currentSession belongs to the Administrateur, we return all the entities		returnCol = ds.Category.all();	}else if(curSess.user.fullName === 'default guest'){ // Si la personne n'est pas logguer				promoteToken = curSess.promoteWith('Read_Access'); // promote the user with the 'Read_Access' group to read the access				allPublicAccesses = ds.Access.query('group.ID == :1',namespace.getPublicGroupID()); // Get all the access of the public group				accessIDArray = allPublicAccesses.ID; // assign all the access ID to the variable				categoryResult = ds.Category.query('forums.allAccesses.ID in :1 and forums.topics.posts # null',accessIDArray); // Query the Category dataClass to get all the data related to the public access		// Alternative of code, do the same but this is much more slower//		categoryResult = allPublicAccesses.forum.category.query('forums.topics.posts # null'); 				returnCol.add(categoryResult); // add the result of the query in the entityCollection				curSess.unPromote(promoteToken); // unpromote the user	}else{				promoteToken = curSess.promoteWith('Read_Access'); // promote the user with the 'Read_Access' group to read the access				allUserAccesses = ds.Access.query('user.ID == :1 or group.allUsers.ID == :1 or group{2}.ID == :2',curSess.storage.userID,namespace.getPublicGroupID()); // Get all the access of the current user plus the one of the public group				accessIDArray = allUserAccesses.ID; // assign all the access ID to the variable				categoryResult = ds.Category.query('forums.allAccesses.ID in :1 or forums.visible == true',accessIDArray); // Query the Category dataClass to get all the data related to the found accesses		// Alternative of code, do the same but this is much more slower//		categoryResult = allUserAccesses.forum.category.query('forums.visible == true');				returnCol.add(categoryResult); // add the result of the query in the entityCollection				curSess.unPromote(promoteToken);// unpromote the user	}		return returnCol; // return the entityCollection	};model.Category.events.remove = function() {	if(this.forums.length !== 0){ // if the category contains at least 1 forum		return { // return an error				error:11,				errorMessage:'You cannot remove this category because it contain forum(s).'				};	}};//  the currentUserUnread attribute is to retreive the number of post unread in the categorymodel.Category.currentUserUnread.onGet = function() {	var curSess = currentSession();		if(curSess.user.fullName === 'default guest' || curSess.user.name === 'dataAdmin' || curSess.user.name === 'admin'){		return 0;	}else{		return this.forums.sum('currentUserUnread');	}};